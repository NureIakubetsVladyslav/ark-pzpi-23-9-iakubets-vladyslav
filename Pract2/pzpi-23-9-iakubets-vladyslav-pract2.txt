Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії





Звіт
до практичного завдання №2
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення: Replace Data Value with Object, Replace Parameter with Method, Replace Record with Data Class у мові С#»







Виконав:
ст. гр. ПЗПІ-23-9
Якубець Владислав Олексійович
	                     Перевірив:
                     ст. викладач кафедри ПІ
                     Сокорчук Ігор Петрович	




Харків 2025
1 ІСТОРІЯ ЗМІН
№	Дата	Версія звіту	Опис змін та виправлень
1	27.11.2025	0.1	Початкова версія документу, заповнення всіх розділів





































 
2 ЗАВДАННЯ
1.	Студент повинен обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code».
2.	Навести приклади свого особистого коду (з курсових, лабораторних або інших проєктів), який потребує покращення, та продемонструвати застосування обраних методів.
3.	Кожен метод рефакторингу повинен супроводжуватись:
Описом проблеми, яку вирішує даний метод. Кодом до і після застосування методу рефакторингу. Поясненням переваг використаного методу.






 
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ    
У процесі розробки програмного забезпечення логіка застосунку з часом ускладнюється, а вимоги до проєкту змінюються. Це може призвести до появи так званих «запахів коду» - фрагментів, які формально працюють, але мають проблеми зі структурою, дублюють функціональність, порушують принципи інкапсуляції або містять зайву складність. Такі недоліки не завжди помітні на початкових етапах, але значно ускладнюють подальший розвиток і підтримку програми.
Рефакторинг - це процес покращення внутрішньої структури коду без зміни його поведінки. Він забезпечує підвищення читабельності коду, зменшення дублювання, посилення зв’язності між сутностями та спрощення архітектури. Виконання рефакторингу має особливу цінність у навчальних і курсових проєктах, оскільки дозволяє побачити власні помилки, зрозуміти принципи якісного програмного дизайну та отримати реальний досвід покращення існуючого рішення.
Для практичної частини цієї роботи було обрано мій курсовий проєкт - гру «MinedOut», створену у рамках вивчення WinForms та основ об’єктно-орієнтованого програмування. Переглянувши вихідний код через призму принципів з книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code», я виявив кілька характерних недоліків та застосував відповідні методи рефакторингу для їх усунення.
3.2 Вибір методів рефакторингу
Під час перегляду коду гри «MinedOut» я звернув увагу на декілька недоліків, що ускладнювали підтримку проєкту: надмірне використання примітивних структур, передача зайвих параметрів між методами та відсутність чіткого опису деяких сутностей. Для вдосконалення архітектури я підібрав три методи рефакторингу, які найкраще відповідали виявленим проблемам:
	Replace Data Value with Object (Замінити значення даних на об'єкт);
	Replace Parameter with Method (Замінити параметр методом);
	Replace Record with Data Class (Замінити запис класом даних).
3.3 Метод 1: Replace Data Value with Object
3.3.1 Опис проблеми
Стан однієї клітинки ігрового поля описується відразу кількома масивами: grid визначає тип клітинки, mines містить інформацію про наявність міни, а revealedMines - про її відображення. Це призводить до дублювання логіки та порушення цілісності даних. Будь-яка зміна в одній властивості клітинки вимагає оновлення кількох масивів, що збільшує ризик помилок. Така модель не відповідає принципам об’єктно-орієнтованого програмування і ускладнює подальший розвиток гри.
3.3.2 Суть методу
Метод Replace Data Value with Object полягає в тому, щоб замінити набір пов’язаних примітивних даних окремим класом-об’єктом. Замість того, щоб зберігати характеристики сутності у вигляді розрізнених значень (масивів, полів тощо), вводиться спеціальний тип, який інкапсулює ці дані в одному місці. Такий підхід робить модель предметної області більш очевидною, спрощує роботу з даними, підвищує гнучкість і дозволяє легко додавати нову поведінку або властивості.
3.3.3 Код до рефакторингу
1 public class Game
2 {
3     private readonly int rows;
4     private readonly int cols;
5     private readonly CellType[,] grid;
6     private readonly bool[,] mines;
7     private readonly bool[,] revealedMines;
8     private readonly Random random = new Random();
9 
10    public Game(int rows, int cols)
11    {
12        this.rows = rows;
13        this.cols = cols;
14        grid = new CellType[rows, cols];
15        mines = new bool[rows, cols];
16        revealedMines = new bool[rows, cols];
17    }
18
19    public void InitializeMines(int mineCount)
20    {
21        int placed = 0;
22        while (placed < mineCount)
23        {
24            int row = random.Next(1, rows - 1);
25            int col = random.Next(1, cols - 1);
26            if (!mines[row, col] && grid[row, col] != CellType.Start)
27            {
28                mines[row, col] = true;
29                placed++;
30            }
31        }
32    }
33
34    public bool IsMine(int row, int col) => mines[row, col];
35 }
3.3.4 Пояснення обраного методу
У моєму проєкті одна клітинка поля фактично мала кілька пов’язаних характеристик, але вони були розподілені між різними масивами. Це типовий приклад, коли сутність представлена не як об’єкт, а як набір примітивів. Застосування методу Replace Data Value with Object дозволило виділити окремий клас Cell, який зберігає всю інформацію про клітинку в одному місці. Завдяки цьому логіка роботи з клітинками стала більш прозорою: тепер я оперую не окремими масивами, а об’єктами, які краще відповідають реальній моделі гри. Це зробило код більш об’єктно-орієнтованим і зручним для розвитку.
3.3.5 Код після рефакторингу
1 public class Cell
2 {
3     public CellType Type { get; set; } = CellType.Empty;
4     public bool HasMine { get; set; }
5     public bool IsMineRevealed { get; set; }
6 }
7 
8 public class Game
9 {
10    private readonly int rows;
11    private readonly int cols;
12    private readonly Cell[,] grid;
13    private readonly Random random = new Random();
14
15    public Game(int rows, int cols)
16    {
17        this.rows = rows;
18        this.cols = cols;
19        grid = new Cell[rows, cols];
20        for (int r = 0; r < rows; r++)
21            for (int c = 0; c < cols; c++)
22                grid[r, c] = new Cell();
23    }
24
25    public void InitializeMines(int mineCount)
26    {
27        int placed = 0;
28        while (placed < mineCount)
29        {
30            int row = random.Next(1, rows - 1);
31            int col = random.Next(1, cols - 1);
32            if (!grid[row, col].HasMine && grid[row, col].Type != CellType.Start)
33            {
34                grid[row, col].HasMine = true;
35                placed++;
36            }
37        }
38    }
39
40    public bool IsMine(int row, int col) => grid[row, col].HasMine;
41 }
3.3.6 Переваги отриманого коду після застосування методу
Після рефакторингу стан клітинки більше не розкиданий по кількох масивах, а зосереджений у класі Cell. Це покращило читабельність коду: звернення на кшталт grid[row, col].HasMine інтуїтивно зрозуміліші, ніж робота з паралельними масивами. Модель стала гнучкішою - додавання нових властивостей клітинки тепер зводиться до зміни одного класу, без модифікації кількох структур даних. Також зменшився ризик логічних помилок, пов’язаних із несинхронними оновленнями масивів, що позитивно вплинуло на надійність та підтримуваність програмного коду.
3.4 Метод 2: Replace Parameter with Method
3.4.1 Опис проблеми
В класі MainForm є методи, відповідальні за оновлення візуального стану поля: UpdateGameView та UpdateCellView. Спочатку вони приймають об’єкт гравця як параметр (Player currentPlayer), хоча у формі вже існує поле player, яке зберігає поточного гравця. Усі виклики виглядають як UpdateGameView(player) і обов’язково передають той самий об’єкт. Це призводить до дублювання даних у сигнатурах, ускладнює методи й створює зайву можливість помилки (наприклад, передає не того гравця). Фактично методи логічно працюють з «поточним гравцем форми», але їх інтерфейс написаний так, ніби вони призначені для довільного гравця.
3.4.2 Суть методу
Метод рефакторингу Replace Parameter with Method полягає в тому, щоб видалити параметр, значення якого завжди можна отримати з внутрішнього стану об’єкта, і замінити його викликом методу або доступом до поля. Якщо певна функція завжди використовує одні й ті самі дані (наприклад, поточного гравця, активний документ, вибраний елемент) і ці дані вже доступні всередині класу, немає сенсу передавати їх як аргументи. Такий підхід робить сигнатури методів простішими, зменшує дублювання та ризик помилок при виклику, а також посилює інкапсуляцію, оскільки деталі отримання потрібних значень приховуються всередині класу.
3.4.3 Код до рефакторингу
1  private void UpdateGameView(Player currentPlayer)
2  {
3      for (int i = 0; i < Rows; i++)
4      {
5          for (int j = 0; j < Cols; j++)
6          {
7              UpdateCellView(i, j, currentPlayer);
8          }
9      }
10
11     int mineCount = game.GetSurroundingMineCount(currentPlayer.Row, currentPlayer.Col);
12     mineCountLabel.Text = $"Мiн поряд: {mineCount}";
13 }
14
15 private void UpdateCellView(int row, int col, Player currentPlayer)
16 {
17     cells[row, col].Image = null;
18
19     if (game.IsWall(row, col))
20         cells[row, col].BackColor = Color.Gray;
21     else if (game.IsFinish(row, col))
22         cells[row, col].BackColor = Color.White;
23     else
24         cells[row, col].BackColor = Color.White;
25
26     if (currentPlayer.Row == row && currentPlayer.Col == col)
27         cells[row, col].Image = GameMinedOut.Properties.Resources.player;
28 }
29
30 // Виклик методу
31 UpdateGameView(player);
3.4.4 Пояснення обраного методу
У моєму проєкті методи UpdateGameView та UpdateCellView фактично працювали завжди з одним і тим самим гравцем - тим, що зберігається у полі player всередині MainForm. Параметр currentPlayer не додавав гнучкості, а лише дублював інформацію, вже доступну класу. Це є типовим прикладом ситуації, коли метод отримує параметр, який він міг би отримати самостійно через власний стан. Застосування методу Replace Parameter with Method дозволяє прибрати цей зайвий параметр, а всередині методу звертатися напряму до поля player. Такий підхід спрощує сигнатури, зменшує кількість аргументів у викликах і робить код менш вразливим до помилок, пов’язаних з передачею некоректних значень. Крім того, це краще відображає реальну модель, метод оновлює саме поточного гравця форми, а не довільно переданого ззовні.
3.4.5 Код після рефакторингу
1  private void UpdateGameView()
2  {
3      for (int i = 0; i < Rows; i++)
4      {
5          for (int j = 0; j < Cols; j++)
6          {
7              UpdateCellView(i, j);
8          }
9      }
10
11     int mineCount = game.GetSurroundingMineCount(player.Row, player.Col);
12     mineCountLabel.Text = $"Мiн поряд: {mineCount}";
13 }
14
15 private void UpdateCellView(int row, int col)
16 {
17     cells[row, col].Image = null;
18
19     if (game.IsWall(row, col))
20         cells[row, col].BackColor = Color.Gray;
21     else if (game.IsFinish(row, col))
22         cells[row, col].BackColor = Color.White;
23     else
24         cells[row, col].BackColor = Color.White;
25
26     if (player.Row == row && player.Col == col)
27         cells[row, col].Image = GameMinedOut.Properties.Resources.player;
28 }
29
30 // Оновлений виклик методу
31 UpdateGameView();
3.4.6 Переваги отриманого коду після застосування методу
Після застосування методу Replace Parameter with Method код став помітно простішим та безпечнішим. Сигнатури UpdateGameView() і UpdateCellView(int row, int col) більше не містять зайвих параметрів, а значить, легше сприймаються і використовуються. Зникло дублювання - немає потреби щоразу передавати player в усі виклики, оскільки метод сам отримує потрібні дані з поля форми. Зменшився ризик логічних помилок, пов’язаних з передачею неправильного об’єкта гравця. Посилилася інкапсуляція, деталі того, який саме гравець є «поточним», приховані всередині класу, а зовнішній код лише просить оновити відображення. В результаті код краще відображає реальну структуру програми, легше підтримується і є більш готовим до подальших змін.

3.5 Метод 3: Replace Record with Data Class
3.5.1 Опис проблеми
Координати клітинки поля передаються як два окремі параметри row і col. Така пара значень насправді описує одну логічну сутність - позицію на полі, але в коді вона представлена двома розрізненими числами. Це робить сигнатури методів менш наочними, ускладнює подальшу зміну формату координат і створює ризик помилок (наприклад, переплутати порядок параметрів). Було б зручніше працювати не з “двома int”, а з окремим типом, який явно представляє позицію.
3.5.2 Суть методу
Метод Replace Record with Data Class полягає в заміні “запису”, який представлено набором простих значень, на окремий клас. Замість того щоб всюди передавати розрізнені параметри, вводимо спеціальний тип (data class), який інкапсулює ці дані. У нашому випадку це означає виділення окремого класу Position, який зберігає координати клітинки та використовується у методах, що працюють з позиціями на полі.
3.5.3 Код до рефакторингу
1 public class Game
2 {
3     private readonly int rows;
4     private readonly int cols;
5     private readonly bool[,] mines;
6 
7     public Game(int rows, int cols)
8     {
9         this.rows = rows;
10        this.cols = cols;
11        mines = new bool[rows, cols];
12    }

13    public int GetSurroundingMineCount(int row, int col)
14    {
15        int count = 0;
16        for (int i = -1; i <= 1; i++)
17        {
18            for (int j = -1; j <= 1; j++)
19            {
20                int newRow = row + i;
21                int newCol = col + j;
22                if (newRow >= 0 && newRow < rows &&
23                    newCol >= 0 && newCol < cols &&
24                    mines[newRow, newCol])
25                {
26                    count++;
27                }
28            }
29        }
30        return count;
31    }
32 }
33
34 public class MainForm : Form
35  {
36    private Game game;
37    private Player player;
38    private Label mineCountLabel;
39
40    private void UpdateMineCountLabel()
41    {
42        int mineCount = game.GetSurroundingMineCount(player.Row, player.Col);
43        mineCountLabel.Text = $"Мiн поряд: {mineCount}";
44    }
45 }
3.5.4 Пояснення обраного методу
У цьому варіанті коду позиція на полі завжди передається як пара row і col, але фактично це одна сутність - координата. Застосування методу Replace Record with Data Class дозволяє зробити цю сутність явною, виділивши окремий клас Position. Завдяки цьому методи, які працюють із позиціями, стають зрозумілішими, скорочується кількість параметрів, а сама модель гри виглядає більш об’єктно-орієнтованою. Надалі з таким класом зручніше працювати, додавати перевірки та допоміжні методи.
3.5.5 Код після рефакторингу
1 public class Position
2 {
3     public int Row { get; }
4     public int Col { get; }
5 
6     public Position(int row, int col)
7     {
8         Row = row;
9         Col = col;
10    }
11 }
12 
13 public class Game
14 {
15    private readonly int rows;
16    private readonly int cols;
17    private readonly bool[,] mines;
18
19    public Game(int rows, int cols)
20    {
21        this.rows = rows;
22        this.cols = cols;
23        mines = new bool[rows, cols];
24    }
25
26    public int GetSurroundingMineCount(Position position)
27    {
28        int count = 0;
29        for (int i = -1; i <= 1; i++)
30        {
31            for (int j = -1; j <= 1; j++)
32            {
33                int newRow = position.Row + i;
34                int newCol = position.Col + j;
35                if (newRow >= 0 && newRow < rows &&
36                    newCol >= 0 && newCol < cols &&
37                    mines[newRow, newCol])
38                {
39                    count++;
40                }
41            }
42        }
43        return count;
44    }
45 }
46
47 public class MainForm : Form
48 {
49    private Game game;
50    private Player player;
51    private Label mineCountLabel;
52
53    private void UpdateMineCountLabel()
54    {
55        var position = new Position(player.Row, player.Col);
56        int mineCount = game.GetSurroundingMineCount(position);
57        mineCountLabel.Text = $"Мiн поряд: {mineCount}";
58    }
59 }

3.5.6 Переваги отриманого коду після застосування методу
Після введення класу Position координати вже не виглядають як два випадкові цілі числа, а оформлені в окремий тип, який чітко позначає позицію на полі. Це робить сигнатури методів більш зрозумілими й зменшує ризик помилок, пов’язаних з переплутаними параметрами. Далі клас Position можна розвивати: додати методи порівняння, перевірку сусідніх клітинок, перетворення між різними системами координат тощо. У підсумку код стає чистішим, ближчим до доменної моделі та зручнішим для підтримки.
3.6 Інструменти автоматизації рефакторингу (Visual Studio)
3.6.1 «Rename» (Перейменування)
Інструмент для безпечного перейменування класів, методів, змінних та інших елементів. Викликається через F2 або Quick Actions. На відміну від звичайного редагування тексту, Rename змінює всі посилання на об'єкт у проєкті, запобігаючи помилкам. Це корисно, коли ім'я більше не відображає призначення об'єкта та потребує уточнення.
3.6.2 Меню «Quick Actions» (Швидкі дії)
Це основний інструмент рефакторингу у Visual Studio. Викликається комбінацією Ctrl + ., після чого середовище пропонує контекстні підказки щодо можливих змін у виділеному фрагменті. Через Quick Actions можна перейменовувати змінні, створювати нові методи, виправляти попередження аналізатора коду, замінювати конструкції більш безпечними аналогами тощо. Visual Studio аналізує контекст і пропонує лише релевантні операції, що суттєво прискорює роботу над кодом.
3.6.3 «Extract Method» (Виділення методу)
Дозволяє автоматично винести частину логіки в окремий метод. Після виділення потрібного коду Visual Studio сама створює новий метод, визначає необхідні параметри та замінює початковий фрагмент викликом новоствореної функції. Інструмент корисний для зменшення довжини методів та поліпшення читабельності коду.
3.6.4 Code Cleanup (Очищення коду)
Запускається через значок мітли у статусному рядку редактора. Автоматично застосовує набір правил стилю: вирівнює відступи, сортує using-директиви, виправляє форматування імен, усуває зайві простори та непотрібні імпорти. Це дозволяє швидко привести код до єдиного стилю, що є важливою частиною підтримуваності проєкту.
3.6.5 Refactoring Suggestions (Пропозиції рефакторингу)
Visual Studio постійно аналізує код у фоновому режимі, виявляє потенційні покращення і позначає їх лампочкою біля рядка. Серед пропозицій можуть бути: спрощення умов, заміна циклів на LINQ, інкапсуляція полів у властивості, перетворення масивів у класи та інші автоматизовані дії. Це допомагає не пропустити проблемні місця і поступово підвищувати якість коду.

 
4 ВИСНОВКИ
У ході виконання практичного завдання було детально проаналізовано програмний код курсового проєкту «MinedOut» та застосовано три методи рефакторингу з книги Мартіна Фаулера. Проведені зміни не вплинули на функціональну поведінку гри, однак суттєво покращили її внутрішню структуру, зменшили дублювання логіки та підвищили зрозумілість окремих частин коду.
Метод Replace Data Value with Object дозволив замінити набір розрізнених примітивних значень, що описували стан клітинки, на повноцінний об'єкт. Завдяки цьому зникла потреба в підтримці паралельних масивів, зросла цілісність даних і спростилася робота з атрибутами клітинки.
Метод Replace Parameter with Method усунув надлишкові параметри зі сигнатур методів, що працюють із внутрішнім станом класу. Це підвищило інкапсуляцію, скоротило кількість викликів із дубльованою інформацією та зменшило ризик помилок під час передавання даних.
Метод Replace Record with Data Class сприяв формалізації логічних сутностей, які раніше були представлені примітивами. Уведення окремого класу для позиції на полі покращило читабельність коду, спростило сигнатури методів та створило можливості для подальшого розширення функціональності без зміни базових конструкцій.
Загалом проведений рефакторинг продемонстрував, що навіть працюючий код може мати архітектурні недоліки, які ускладнюють його підтримку. Використання методів рефакторингу дозволило підвищити якість коду, зробити модель гри більш об’єктно-орієнтованою, а програму - легшою для аналізу та майбутнього розвитку. Отримані результати підтверджують важливість систематичного рефакторингу у процесі розробки програмного забезпечення і його роль як невід'ємного елементу професійної програмної практики.
 
5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Учасники проектів Вікімедіа. Рефакторинг – Вікіпедія. Вікіпедія. URL: https://uk.wikipedia.org/wiki/Рефакторинг [дата звернення: 28.11.2025].
2. Refactoring.Guru. Refactoring — what is it? URL: https://refactoring.guru/refactoring [дата звернення: 28.11.2025]
3. Microsoft. Refactor code – Visual Studio. Learn.Microsoft.com. URL: https://learn.microsoft.com/uk-ua/visualstudio/ide/refactoring-in-visual-studio?view=vs-2019 [дата звернення: 28.11.2025].
4. Microsoft. Refactor code – Visual Studio (англ.) Learn.Microsoft.com. URL: https://learn.microsoft.com/en-us/visualstudio/ide/refactoring-in-visual-studio?view=visualstudio [дата звернення: 28.11.2025].
5. Dev.to. Simplify Your C# Code: Top 5 Refactoring Tools. documatic, 10 червня 2023. URL: https://dev.to/documatic/simplify-your-c-code-top-5-refactoring-tools-1bo0 [дата звернення: 28.11.2025].
6. Medium. Kerim Kara. The Art of Code Refactoring in C#. 5 листопада 2023. URL: https://medium.com/@kerimkkara/the-art-of-code-refactoring-in-c-d02f0346a1dd [дата звернення: 28.11.2025].
7. Refactoring.Guru. Catalog of Refactoring Techniques. URL: https://refactoring.guru/refactoring/techniques [дата звернення: 28.11.2025]


 
ДОДАТОК А

Відеозапис: https://youtu.be/IjJLVXJBr7A
Таймкоди до відеозапису:
00:00 - Вступ. Тема доповіді 
00:15 - Що таке рефакторинг? 
00:53 - Вибір методів рефакторингу 
01:04 - Метод 1: Replace Data Value with Object (Проблема) 
01:41 - Метод 1: Replace Data Value with Object (Суть методу) 
02:20 - Метод 1: Replace Data Value with Object (Після рефакторингу) 
03:06 - Метод 2: Replace Parameter with Method (Проблема) 
04:02 - Метод 2: Replace Parameter with Method (Суть методу) 
04:48 - Метод 2: Replace Parameter with Method (Після рефакторингу) 
05:30 - Метод 3: Replace Record with Data Class (Проблема) 
06:07 - Метод 3: Replace Record with Data Class (Суть методу) 
06:39 - Метод 3: Replace Record with Data Class (Після рефакторингу) 
07:20 - Інструменти автоматизації рефакторингу (Visual Studio) 
07:27 - «Rename» (Перейменування) 
08:00 - Меню «Quick Actions» (Швидкі дії) 
08:42 - «Extract Method» (Виділення методу) 
09:09 - Code Cleanup (Очищення коду) 
09:41 - Refactoring Suggestions (Пропозиції рефакторингу) 
10:14 - Висновки 
ДОДАТОК Б

 
Рисунок Б.1 — Титульний аркуш
 
Рисунок Б.2 — Що таке рефакторинг?
 
Рисунок Б.3 — Вибір методів рефакторингу
 
Рисунок Б.4 — Метод 1: Replace Data Value with Object (Проблема)
 
Рисунок Б.5 — Метод 1: Replace Data Value with Object (Суть методу)
 
Рисунок Б.6 — Метод 1: Replace Data Value with Object (Після рефакторингу)
 
Рисунок Б.7 — Метод 2: Replace Parameter with Method (Проблема)
 
Рисунок Б.8 — Метод 2: Replace Parameter with Method (Суть методу)
 
Рисунок Б.9 — Метод 2: Replace Parameter with Method (Після рефакторингу)
 
Рисунок Б.10 — Метод 3: Replace Record with Data Class (Проблема)
 
Рисунок Б.11 — Метод 3: Replace Record with Data Class (Суть методу)
 
Рисунок Б.12 — Метод 3: Replace Record with Data Class (Після рефакторингу)
 
Рисунок Б.13 — Інструменти автоматизації рефакторингу (Visual Studio)
 
Рисунок Б.14 — Висновки
 
ДОДАТОК В

Програмний код
GitHub репозиторій: https://github.com/9Vladislav/future-coursework/tree/main/GameMinedOut
