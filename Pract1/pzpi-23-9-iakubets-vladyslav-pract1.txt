Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії





Звіт
до практичного завдання №1
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Правила оформлення програмного коду на Kotlin»







Виконав:
ст. гр. ПЗПІ-23-9
Якубець Владислав Олексійович
	                     Перевірив:
                     ст. викладач кафедри ПІ
                     Сокорчук Ігор Петрович	





Харків 2025






1 ІСТОРІЯ ЗМІН
№	Дата	Версія звіту	Опис змін та виправлень
1	30.10.2025	0.1	Початкова версія документу, заповнення всіх розділів







 
2 ЗАВДАННЯ
Студент повинен обрати мову програмування, дослідити основні рекомендації для написання якісного коду у цій мові, продемонструвати ці рекомендації на прикладах коду, обґрунтувати кожну рекомендацію і надати детальні пояснення. Для кожного прикладу мають бути наведені фрагменти коду.




 
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ    
Мова програмування Kotlin - це сучасна, зручна та безпечна мова, розроблена компанією JetBrains для використання на платформі Java. Вона поєднує у собі риси об’єктно-орієнтованого та функціонального програмування, забезпечуючи високу виразність синтаксису, безпечність та зручність у використанні. Завдяки сумісності з Java, Kotlin дозволяє розробникам поступово переходити з однієї мови на іншу, використовуючи вже наявний код і бібліотеки. Основною метою розробки Kotlin було спрощення процесу програмування та зменшення кількості шаблонного або повторюваного коду. Мова має низку особливостей, таких як null-безпека, extension-функції, data-класи та лямбда-вирази, що роблять її потужним інструментом для створення чистого, зрозумілого й легко підтримуваного коду. Kotlin активно використовується у розробці Android-додатків, серверних програм, веб-сервісів та навіть десктопних застосунків. Його офіційна підтримка з боку Google сприяє подальшому поширенню та стандартизації стилю написання коду. Саме тому вивчення рекомендацій щодо написання якісного коду на Kotlin має важливе значення для формування навичок професійного програмування та дотримання принципів рефакторингу.
3.2 Рекомендація: Використовуйте осмислені назви змінних, функцій і класів. 
Опис: Імена елементів коду мають чітко відображати їх призначення. Зрозумілі назви допомагають швидше орієнтуватися в коді, зменшують кількість помилок і полегшують подальшу підтримку програми.
Приклад:
1 // Поганий приклад
2 fun c(a: Int, b: Int): Int {
3     return a + b
4 }
5 
6 // Гарний приклад
7 fun calculateSum(firstNumber: Int, secondNumber: Int): Int {
8     return firstNumber + secondNumber
9 }
Пояснення: У Kotlin, як і в більшості сучасних мов, читабельність коду ключ до його якості. Коли імена не відображають суть, розробникам доводиться витрачати час на розуміння логіки. Використання зрозумілих назв знижує ризик помилок під час змін та полегшує рефакторинг у майбутньому.

3.3 Рекомендація: Використовуйте when замість ланцюга if-else.
Опис: Конструкція when у Kotlin є більш читабельною та гнучкою альтернативою довгим умовним операторам if-else. 
Приклад:
1 // Поганий приклад
2 if (status == 0) println("Loading")
3 else if (status == 1) println("Success")
4 else if (status == 2) println("Error")
5 else println("Unknown")
6 
7 // Гарний приклад
8  when (status) {
9      0 -> println("Loading")
10     1 -> println("Success")
11     2 -> println("Error")
12     else -> println("Unknown")
13 }
Пояснення: when робить код структурованішим і легшим для розширення. Якщо з’явиться новий стан, його легко додати без переписування попередніх умов. Це покращує підтримуваність і знижує ризик логічних помилок.

3.4 Рекомендація: Уникайте дублювання коду.
Опис: Повторюваний код ускладнює підтримку програми: будь-яка зміна логіки потребує правок у кількох місцях, що підвищує ризик помилок. У Kotlin слід виносити повторювану логіку в окремі функції або розширення.
Приклад:
1 // Поганий приклад
2 fun calculateSalary(employee: Employee): Double {
3     return employee.hoursWorked * employee.hourlyRate + employee.hoursWorked * 0.1
4 }
5
6 fun calculateBonus(employee: Employee): Double {
7     return employee.hoursWorked * employee.hourlyRate + employee.hoursWorked * 0.1
8 }
9
10 // Гарний приклад
11 fun calculatePayment(employee: Employee): Double {
12     return employee.hoursWorked * (employee.hourlyRate + 0.1)
13 }
14
15 fun calculateSalary(employee: Employee) = calculatePayment(employee)
16 fun calculateBonus(employee: Employee) = calculatePayment(employee)
Пояснення: Усунення дублювання зменшує кількість потенційних помилок, полегшує зміну логіки та робить код компактнішим. Якщо потрібно оновити формулу розрахунку — достатньо змінити її лише в одному місці.

3.5 Рекомендація: Використовуйте лямбда-вирази та колекційні функції.
Опис: Kotlin підтримує функціональний підхід. Замість циклів можна використовувати вбудовані функції, як-от map, filter, forEach, що робить код коротшим і зрозумілішим.
Приклад:
1 // Поганий приклад
2 val numbers = listOf(1, 2, 3, 4, 5)
3 val evenNumbers = mutableListOf<Int>()
4 for (n in numbers) {
5     if (n % 2 == 0) {
6         evenNumbers.add(n)
7     }
8 }
9 
10 // Гарний приклад
11 val numbers = listOf(1, 2, 3, 4, 5)
12 val evenNumbers = numbers.filter { it % 2 == 0 }
Пояснення: Функціональний стиль у Kotlin дозволяє зменшити кількість коду та підвищити його виразність. Такі функції простіше тестувати й модифікувати. Нехтування ними робить програму громіздкою й менш гнучкою для змін.

3.6 Рекомендація: Використовуйте sealed class для обмежених ієрархій.
Опис: Коли потрібно представити набір обмежених станів або типів, зручно використовувати sealed class. Це безпечна альтернатива звичайним спадковим класам, яка дозволяє контролювати всі можливі варіанти.
Приклад:
1 // Поганий приклад
2 open class Result
3 class Success(val data: String) : Result()
4 class Error(val message: String) : Result()
5 
6 fun handle(result: Result) {
7     if (result is Success) println("Успіх: ${result.data}")
8     else if (result is Error) println("Помилка: ${result.message}")
9 }
10 
11 // Гарний приклад
12 sealed class Result
13 data class Success(val data: String) : Result()
14 data class Error(val message: String) : Result()
15
16 fun handle(result: Result) = when (result) {
17     is Success -> println("Успіх: ${result.data}")
18     is Error -> println("Помилка: ${result.message}")
19 }
Пояснення: sealed class дозволяє компілятору гарантувати, що всі варіанти типів опрацьовані у when. Це підвищує безпечність і запобігає забутим гілкам коду при оновленні логіки програми.

3.7 Рекомендація: Уникайте глибокої вкладеності коду.
Опис: Глибоко вкладені цикли або умовні оператори ускладнюють розуміння програми. У Kotlin можна використовувати оператори return, continue, break, або ж функції вищого порядку (takeIf, let, also) для спрощення логіки.
Приклад:
1 // Поганий приклад
2 for (user in users) {
3     if (user.isActive) {
4         if (user.balance > 0) {
5             println("Активний користувач: ${user.name}")
6         }
7     }
8 }
9 
10 // Гарний приклад
11 users.filter { it.isActive && it.balance > 0 }
12      .forEach { println("Актвний користувач: ${it.name}") }
Пояснення: Спрощення вкладеності робить код чистішим і легшим для сприйняття. Завдяки функціям вищого порядку можна виразити ту саму логіку значно коротше й без втрати змісту. Це позитивно впливає на підтримку та тестування програми.

3.8 Рекомендація: Дотримуйтеся єдиного стилю оформлення коду.
Опис: Послідовне форматування (відступи, пробіли, розташування дужок) підвищує читабельність. Kotlin має офіційний Kotlin Style Guide, який регламентує відступи, назви та форматування.
Приклад:
1 // Поганий приклад
2 fun getUserInfo (id:Int):String{
3 val user=database.getUserById(id)
4 if(user!=null){
5 println("Ім'я:"+user.name)
6 println("Вік:"+user.age)}
7 else{
8 println("Користувача не знайдено")}
9 return "Кінець виконання"
10 }
11
12 // Гарний приклад
13 fun getUserInfo(id: Int): String {
14     val user = database.getUserById(id)
15     if (user != null) {
16         println("Ім’я: ${user.name}")
17         println("Вік: ${user.age}")
18     } else {
19         println("Користувача не знайдено")
20     }
21     return "Кінець виконання"
22 }
Пояснення: Непослідовний стиль ускладнює читання й роботу в команді. Форматування не впливає на логіку, але безпосередньо впливає на сприйняття якості. Інструменти, як-от ktlint або IntelliJ Formatter, допомагають підтримувати єдиний стиль автоматично.

3.9 Рекомендація: Використовуйте null-безпечні типи та оператори.
Опис: Kotlin має вбудовану систему null-безпеки, яка допомагає уникнути однієї з найчастіших помилок - NullPointerException. Для цього використовуються nullable-типи (String?), оператор ?. і оператор ?:
Приклад:
1 // Поганий приклад
2 val user: User? = database.findUserById(5)
3 println(user.name) // Runtime помилка!
4 
5 // Гарний приклад
6 val user: User? = database.findUserById(5)
7 val name = user?.name ?: "Невідомо"
8 println("Ім’я користувача: $name")
Пояснення: Null-безпека - одна з найважливіших рис Kotlin. Завдяки їй більшість помилок виявляється ще на етапі компіляції. Ігнорування nullable-типів робить програму нестабільною й ускладнює рефакторинг.

3.10 Рекомендація: Уникайте надмірної оптимізації передчасно.
Опис: Не варто намагатися зробити код максимально швидким чи коротким до того, як з’явиться реальна потреба. Передчасна оптимізація часто шкодить зрозумілості.
Приклад:
1 // Поганий приклад
2 fun sum(arr: List<Int>) = arr.fold(0) { acc, i -> acc + (i shr 1 shl 1) } // заплутано
3
4 // Гарний приклад
5 fun sum(arr: List<Int>): Int {
6     var total = 0
7     for (i in arr) {
8         total += i
9     }
10     return total
11 }
Пояснення: Код повинен бути передусім зрозумілим, а не хитро “оптимізованим”. Якщо з’явиться потреба підвищити продуктивність, це робиться після вимірювання показників і з урахуванням архітектури.

3.11 Рекомендація: Коментарі лише там, де це справді потрібно.
Опис: Коментарі мають пояснювати чому ви зробили певне рішення, а не що саме робить код. Надмірна кількість коментарів або коментарі, що дублюють очевидну логіку, лише засмічують програму.
Приклад:
1 // Поганий приклад
2 // Додає 10 до значення
3 fun addTen(value: Int): Int {
4     return value + 10
5 }
6 
7 // Гарний приклад
8 // Додає стандартну премію до зарплати відповідно до політики компанії
9 fun addBonus(salary: Int): Int {
10     val bonus = 10
11     return salary + bonus
12 }
Пояснення: Хороший код має бути самодокументованим через осмислені назви функцій і змінних. Коментарі потрібні лише там, де є нетривіальна логіка або важливі бізнес-правила. Це робить програму чистішою й полегшує підтримку.

3.12 Рекомендація: Використовуйте логічні групи функцій.
Опис: Функції, які працюють з однією сутністю або виконують схожі завдання, повинні бути згруповані в одному місці у класі, файлі чи модулі.
Приклад:
1 // Поганий приклад
2 fun addUser(user: User) = println("Додано користувача: ${user.name}")
3 fun calculateTax(order: Order) = println("Податок: ${order.total * 0.2}")
4 fun deleteUser(id: Int) = println("Видалено користувача з ID: $id")
5 
6 // Гарний приклад
7 object UserService {
8     fun add(user: User) = println("Додано користувача: ${user.name}")
9     fun delete(id: Int) = println("Видалено користувача з ID: $id")
10 }
Пояснення: Групування функцій полегшує пошук потрібного методу, зменшує хаос і робить код більш логічним. Це також полегшує роботу з великими проєктами.

3.13 Рекомендація: Використовуйте try-catch для передбачуваної обробки помилок.
Опис: Будь-який код, який може викликати помилку, потрібно обгорнути у try-catch. Проте обробка має бути осмисленою - не можна просто “глушити” помилки.
Приклад:
1 // Поганий приклад
2 try {
3     val text = File("data.txt").readText()
4 } catch (e: Exception) {
5     // Ігноруємо виняток — погана практика
6 }
7 
8 // Гарний приклад
9 try {
10     val text = File("data.txt").readText()
11     println("Файл успішно прочитано!")
12 } catch (e: IOException) {
13     println("Помилка читання файлу: ${e.message}")
14 }
Пояснення: Коректна обробка винятків допомагає уникати збоїв у роботі програми та спрощує пошук причин помилок. Ігнорування виключень - один із найгірших антипатернів у коді.
 
4 ВИСНОВКИ
У ході виконання практичного завдання було досліджено основні принципи написання якісного, чистого та підтримуваного коду мовою програмування Kotlin. На основі офіційних рекомендацій і практичних прикладів розглянуто низку правил, дотримання яких забезпечує високу читабельність, надійність і розширюваність програмного продукту. Було продемонстровано, що грамотне використання таких можливостей, як null-безпека, лямбда-вирази, data-класи, sealed-класи та extension-функції, значно підвищує якість програмного коду. Також важливу роль відіграють загальні принципи програмування осмислене іменування змінних, уникнення дублювання коду, підтримка єдиного стилю оформлення, розділення обов’язків між функціями, правильне коментування та структурованість логіки.
Дотримання цих рекомендацій дозволяє створювати код, який легко читати, тестувати, змінювати та масштабувати. Це не лише зменшує кількість помилок і час на відлагодження, а й полегшує командну роботу під час розробки великих проєктів.
Мова Kotlin, завдяки своїй лаконічності, типобезпеці та підтримці сучасних парадигм програмування, є чудовим інструментом для вивчення принципів аналізу та рефакторингу коду, а засвоєння навичок написання чистого коду є невід’ємною складовою формування професійного програміста.
 
5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Kotlin documentation: Basic syntax [Електронний ресурс]. – URL: https://kotlinlang.org/docs/basic-syntax.html (дата звернення: 30.10.2025).
2. Обговорення на форумі DOU: «Правила написання чистого коду на Kotlin» [Електронний ресурс]. – URL: https://dou.ua/forums/topic/42528 (дата звернення: 30.10.2025).
3. Учасники проектів Вікімедіа. Kotlin – Вікіпедія. Вікіпедія. URL: https://uk.wikipedia.org/wiki/Kotlin (дата звернення: 30.10.2025).
4. Обговорення на форумі DOU: «H&S-6: Detekt і інші способи      зловити проблеми до проду» [Електронний ресурс]. URL: https://dou.ua/forums/topic/54451 (дата звернення: 30.10.2025).
5. Kotlin – що потрібно знати розробнику [Електронний ресурс]. – WAYUP, 14 липня 2025. URL: https://wayup.in/ua/blog/kotlin (дата звернення: 30.10.2025).
6. Coding conventions: Control flow statements [Електронний ресурс]. – Kotlin Lang. URL: https://kotlinlang.org/docs/coding-conventions.html#control-flow-statements (дата звернення: 30.10.2025).
7. Стаття «Мова програмування Kotlin – що потрібно знати розробнику» [Електронний ресурс]. – Lemon School. URL: https://lemon.school/blog/mova-programuvannya-kotlin (дата звернення: 30.10.2025).


 
ДОДАТОК А

Відеозапис: https://youtu.be/I2jTUeQYuvU
Таймкоди до відеозапису:
00:00 Привітання 
00:18 Вступ 
01:17 Використовуйте осмислені назви змінних, функцій і класів 
01:46 Використовуйте when замість ланцюга if-else 02:08 Уникайте дублювання коду 
02:27 Використовуйте лямбда-вирази та колекційні функції 02:57 Використовуйте sealed class для обмежених ієрархій 
03:22 Уникайте глибокої вкладеності коду 
03:44 Дотримуйтеся єдиного стилю оформлення коду 
04:07 Використовуйте null-безпечні типи та оператори 
04:35 Уникайте надмірної оптимізації передчасно 
05:01 Коментарі лише там, де це справді потрібно 
05:32 Використовуйте логічні групи функцій 
05:54 Використовуйте try-catch для передбачуваної обробки помилок 
06:27 Висновки
 
ДОДАТОК Б

 
Рисунок Б.1 — Титульний аркуш
 
Рисунок Б.2 — Вступ
 
Рисунок Б.3 — Використовуйте осмислені назви змінних, функцій і класів
 
Рисунок Б.4 — Використовуйте when замість ланцюга if-else
 
Рисунок Б.5 — Уникайте дублювання коду
 
Рисунок Б.6 — Використовуйте лямбда-вирази та колекційні функції
 
Рисунок Б.7 — Використовуйте sealed class для обмежених ієрархій
 
Рисунок Б.8 — Уникайте глибокої вкладеності коду
 
Рисунок Б.9 — Дотримуйтеся єдиного стилю оформлення коду
 
Рисунок Б.10 — Використовуйте null-безпечні типи та оператори
 
Рисунок Б.11 — Уникайте надмірної оптимізації передчасно
 
Рисунок Б.12 — Коментарі лише там, де це справді потрібно
 
Рисунок Б.13 — Використовуйте логічні групи функцій
 
Рисунок Б.14 — Використовуйте try-catch для передбачуваної обробки помилок
 
Рисунок Б.15 — Висновки
 
ДОДАТОК В

Посилання на програмний код: https://github.com/NureIakubetsVladyslav/ark-pzpi-23-9-iakubets-vladyslav/blob/main/Pract1/pzpi-23-9-iakubets-vladyslav-pract1/code-examples.kt


